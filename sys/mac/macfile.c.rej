***************
*** 62,187 ****
  
  
  static int
! OpenHandleFile ( const unsigned char * name , long fileType )
  {
! 	int i ;
  	OSErr err;
! 	Handle h ;
! 	Str255 s ;
  
! 	for ( i = 0 ; i < MAX_HF ; i ++ ) {
! 		if ( theHandleFiles[i].data == 0L ) break ;
  	}
  	
! 	if ( i >= MAX_HF ) {
  		error("Ran out of HandleFiles");
! 		return -1 ;
  	}
  
! 	h = GetNamedResource ( fileType , name ) ;
  	err = ResError();
  	if (err == resNotFound) return -1;  /* Don't complain, this might be normal */
! 	if ( ! itworked(err) ) return -1;
  	
  	theHandleFiles[i].data = h;
! 	theHandleFiles[i].size = GetHandleSize ( h ) ;
! 	GetResInfo ( h, & theHandleFiles[i].id, ( void* ) & theHandleFiles[i].type, s ) ;
! 	theHandleFiles[i].mark = 0L ;
  
  	return(i + FIRST_HF);
  }
  
  
  static int
! CloseHandleFile ( int fd )
  {
! 	if ( ! IsHandleFile ( fd ) ) {
  	   error("CloseHandleFile: isn't a handle");
! 	   return -1 ;
  	}
! 	fd -= FIRST_HF ;
! 	ReleaseResource ( theHandleFiles[fd].data ) ;
! 	theHandleFiles[fd].data = 0L ;
  	return(0);
  }
  
  
  static int
! ReadHandleFile ( int fd , void * ptr , unsigned len )
  {
! 	unsigned maxBytes ;
! 	Handle h ;
  
! 	if ( ! IsHandleFile ( fd ) ) return -1;
  	
! 	fd -= FIRST_HF ;
! 	maxBytes = theHandleFiles[fd].size - theHandleFiles[fd].mark ;
! 	if ( len > maxBytes ) len = maxBytes ;
  	
! 	h = theHandleFiles[fd].data ;
  	
  	HLock(h);
! 	BlockMove ( *h + theHandleFiles[fd].mark , ptr , len );
  	HUnlock(h);
! 	theHandleFiles[fd].mark += len ;
  	
  	return(len);
  }
  
  
  static long
! SetHandleFilePos ( int fd , short whence , long pos )
  {
  	long curpos;
  	
! 	if ( ! IsHandleFile ( fd ) ) return -1;
  	
! 	fd -= FIRST_HF ;
  	
! 	curpos = theHandleFiles [ fd ].mark;
! 	switch ( whence ) {
  		case SEEK_CUR : 
! 			curpos += pos ;
! 			break ;
  		case SEEK_END : 
! 			curpos = theHandleFiles[fd].size  - pos ;
! 			break ;
  		default : /* set */
! 			curpos = pos ;
! 			break ;
  	}
  
! 	if ( curpos < 0 )
! 		curpos = 0 ;
! 	else if ( curpos > theHandleFiles [ fd ].size )
! 		curpos = theHandleFiles [ fd ].size ;
  	
! 	theHandleFiles [ fd ].mark = curpos;
  	
! 	return curpos ;
  }
  
  
  void
! C2P ( const char * c , unsigned char * p )
  {
! 	long len = strlen ( c ) ;
  
! 	if ( len > 255 ) len = 255 ;
  
! 	p[0] = len & 0xff ;
! 	while (*c) *++p = *c++;
  }
  
  void
! P2C ( const unsigned char * p , char * c )
  {
! 	int idx = p[0];
! 	c[idx] = '\0';
! 	while (idx > 0) {
! 		c[idx-1] = p[idx];
! 		--idx;
! 	}
  }
  
  
--- 63,187 ----
  
  
  static int
! OpenHandleFile (const unsigned char *name, long fileType)
  {
! 	int i;
  	OSErr err;
! 	Handle h;
! 	Str255 s;
  
! 	for (i = 0; i < MAX_HF; i ++) {
! 		if (theHandleFiles[i].data == 0L) break;
  	}
  	
! 	if (i >= MAX_HF) {
  		error("Ran out of HandleFiles");
! 		return -1;
  	}
  
! 	h = GetNamedResource (fileType, name);
  	err = ResError();
  	if (err == resNotFound) return -1;  /* Don't complain, this might be normal */
! 	if (!itworked(err)) return -1;
  	
  	theHandleFiles[i].data = h;
! 	theHandleFiles[i].size = GetHandleSize (h);
! 	GetResInfo (h, &theHandleFiles[i].id, (void*) &theHandleFiles[i].type, s);
! 	theHandleFiles[i].mark = 0L;
  
  	return(i + FIRST_HF);
  }
  
  
  static int
! CloseHandleFile (int fd)
  {
! 	if (!IsHandleFile (fd)) {
  	   error("CloseHandleFile: isn't a handle");
! 	   return -1;
  	}
! 	fd -= FIRST_HF;
! 	ReleaseResource (theHandleFiles[fd].data);
! 	theHandleFiles[fd].data = 0L;
  	return(0);
  }
  
  
  static int
! ReadHandleFile (int fd, void *ptr, unsigned len)
  {
! 	unsigned maxBytes;
! 	Handle h;
  
! 	if (!IsHandleFile (fd)) return -1;
  	
! 	fd -= FIRST_HF;
! 	maxBytes = theHandleFiles[fd].size - theHandleFiles[fd].mark;
! 	if (len > maxBytes) len = maxBytes;
  	
! 	h = theHandleFiles[fd].data;
  	
  	HLock(h);
! 	BlockMove (*h + theHandleFiles[fd].mark, ptr, len);
  	HUnlock(h);
! 	theHandleFiles[fd].mark += len;
  	
  	return(len);
  }
  
  
  static long
! SetHandleFilePos (int fd, short whence, long pos)
  {
  	long curpos;
  	
! 	if (!IsHandleFile (fd)) return -1;
  	
! 	fd -= FIRST_HF;
  	
! 	curpos = theHandleFiles [fd].mark;
! 	switch (whence) {
  		case SEEK_CUR : 
! 			curpos += pos;
! 			break;
  		case SEEK_END : 
! 			curpos = theHandleFiles[fd].size  - pos;
! 			break;
  		default : /* set */
! 			curpos = pos;
! 			break;
  	}
  
! 	if (curpos < 0)
! 		curpos = 0;
! 	else if (curpos > theHandleFiles [fd].size)
! 		curpos = theHandleFiles [fd].size;
  	
! 	theHandleFiles [fd].mark = curpos;
  	
! 	return curpos;
  }
  
  
  void
! C2P (const char *c, unsigned char *p)
  {
! 	int len = strlen (c), i;
  
! 	if (len > 255) len = 255;
  
! 	for (i = len; i > 0; i--)
! 		p[i] = c[i-1];
! 	p[0] = len;
  }
  
  void
! P2C (const unsigned char *p, char *c)
  {
! 	int idx = *p++;
! 	for (; idx > 0; idx--)
! 		*c++ = *p++;
! 	*c = '\0';
  }
  
  
***************
*** 256,399 ****
  	 * we fail with default, etc. etc. Besides, we should use HOpen
  	 * and permissions.
  	 */
! 	if ( ( flags & O_RDONLY ) == O_RDONLY ) {
! 		perm = fsRdPerm ;
  	}
! 	if ( ( flags & O_WRONLY ) == O_WRONLY ) {
! 		perm = fsWrPerm ;
  	}
! 	if ( ( flags & O_RDWR ) == O_RDWR ) {
! 		perm = fsRdWrPerm ;
  	}
! 	if ( HOpen ( theDirs.dataRefNum , theDirs.dataDirID , s ,
! 		perm , & refNum ) ) {
! 		return OpenHandleFile ( s , fileType ) ;
! 	}
! 	if ( flags & O_TRUNC ) {
! 		if ( SetEOF ( refNum , 0L ) ) {
! 			FSClose ( refNum ) ;
! 			return -1 ;
  		}
  	}
! 	return refNum ;
  }
  
  
  int
! macclose ( int fd )
  {
! 	if ( IsHandleFile ( fd ) ) {
! 		CloseHandleFile ( fd ) ;
  	} else {
! 		if ( FSClose ( fd ) ) {
! 			return -1 ;
  		}
! 		FlushVol ( (StringPtr) 0 , theDirs . dataRefNum ) ;
  	}
! 	return 0 ;
  }
  
  
  int
! macread ( int fd , void * ptr , unsigned len )
  {
  	long amt = len;
  	
! 	if ( IsHandleFile ( fd ) ) {
  
! 		return ReadHandleFile ( fd , ptr , amt ) ;
  	} else {
  
! 		short err = FSRead ( fd , & amt , ptr ) ;
! 		if ( err == eofErr && len ) {
  
! 			return amt ;
  		}
! 		if  ( itworked ( err ) ) {
  
! 			return ( amt ) ;
  
  		} else {
  
! 			return -1 ;
  		}
  	}
  }
  
  #if 0 /* this function isn't used, if you use it, uncomment prototype in macwin.h */
  char *
! macgets ( int fd , char * ptr , unsigned len )
  {
!         int idx = 0 ;
          char c;
  
!         while ( -- len > 0 ) {
!                 if ( macread ( fd , ptr + idx , 1 ) <= 0 )
!                         return (char *)0 ;
!                 c = ptr[ idx++ ];
!                 if ( c  == '\n' || c == '\r' )
!                         break ;
          }
!         ptr [ idx ] = '\0' ;
!         return ptr ;
  }
  #endif /* 0 */
  
  
  int
! macwrite ( int fd , void * ptr , unsigned len )
  {
! 	long amt = len ;
  
! 	if ( IsHandleFile ( fd ) ) return -1 ;
  	
! 	if ( itworked( FSWrite ( fd , & amt , ptr ) ) ) return(amt) ;
! 		else return(-1) ;
  }
  
  
  long
! macseek ( int fd , long where , short whence )
  {
! 	short posMode ;
! 	long curPos ;
  
! 	if ( IsHandleFile ( fd ) ) {
! 		return SetHandleFilePos ( fd , whence , where ) ;
  	}
  
! 	switch ( whence ) {
  		default :
! 			posMode = fsFromStart ;
! 			break ;
  		case SEEK_CUR :
! 			posMode = fsFromMark ;
! 			break ;
  		case SEEK_END :
! 			posMode = fsFromLEOF ;
! 			break ;
  	}
  
! 	if ( itworked( SetFPos ( fd , posMode, where ) )  &&
! 	     itworked( GetFPos ( fd , &curPos )) )
! 		    return(curPos);
  	   
  	return(-1);
  }
  
  /* ---------------------------------------------------------------------- */
  
! boolean rsrc_dlb_init(void)
! {
  	return TRUE;
  }
  
! void rsrc_dlb_cleanup(void)
! {
  }
  
! boolean rsrc_dlb_fopen(dlb *dp, const char *name, const char *mode)
! {
  	Str255 pname;
  	
  	C2P(name, pname);
--- 255,396 ----
  	 * we fail with default, etc. etc. Besides, we should use HOpen
  	 * and permissions.
  	 */
! 	if ((flags & O_RDONLY) == O_RDONLY) {
! 		perm = fsRdPerm;
  	}
! 	if ((flags & O_WRONLY) == O_WRONLY) {
! 		perm = fsWrPerm;
  	}
! 	if ((flags & O_RDWR) == O_RDWR) {
! 		perm = fsRdWrPerm;
  	}
! 	if (HOpen (theDirs.dataRefNum, theDirs.dataDirID, s, perm, &refNum)) {
! 		return OpenHandleFile (s, fileType);
! 	}
! 	if (flags & O_TRUNC) {
! 		if (SetEOF (refNum, 0L)) {
! 			FSClose (refNum);
! 			return -1;
  		}
  	}
! 	return refNum;
  }
  
  
  int
! macclose (int fd)
  {
! 	if (IsHandleFile (fd)) {
! 		CloseHandleFile (fd);
  	} else {
! 		if (FSClose (fd)) {
! 			return -1;
  		}
! 		FlushVol ((StringPtr) 0, theDirs . dataRefNum);
  	}
! 	return 0;
  }
  
  
  int
! macread (int fd, void *ptr, unsigned len)
  {
  	long amt = len;
  	
! 	if (IsHandleFile (fd)) {
  
! 		return ReadHandleFile (fd, ptr, amt);
  	} else {
  
! 		short err = FSRead (fd, &amt, ptr);
! 		if (err == eofErr && len) {
  
! 			return amt;
  		}
! 		if  (itworked (err)) {
  
! 			return (amt);
  
  		} else {
  
! 			return -1;
  		}
  	}
  }
  
  #if 0 /* this function isn't used, if you use it, uncomment prototype in macwin.h */
  char *
! macgets (int fd, char *ptr, unsigned len)
  {
!         int idx = 0;
          char c;
  
!         while (-- len > 0) {
!                 if (macread (fd, ptr + idx, 1) <= 0)
!                         return (char *)0;
!                 c = ptr[idx++];
!                 if (c  == '\n' || c == '\r')
!                         break;
          }
!         ptr [idx] = '\0';
!         return ptr;
  }
  #endif /* 0 */
  
  
  int
! macwrite (int fd, void *ptr, unsigned len)
  {
! 	long amt = len;
  
! 	if (IsHandleFile (fd)) return -1;
  	
! 	if (itworked(FSWrite (fd, &amt, ptr))) return(amt);
! 		else return(-1);
  }
  
  
  long
! macseek (int fd, long where, short whence)
  {
! 	short posMode;
! 	long curPos;
  
! 	if (IsHandleFile (fd)) {
! 		return SetHandleFilePos (fd, whence, where);
  	}
  
! 	switch (whence) {
  		default :
! 			posMode = fsFromStart;
! 			break;
  		case SEEK_CUR :
! 			posMode = fsFromMark;
! 			break;
  		case SEEK_END :
! 			posMode = fsFromLEOF;
! 			break;
  	}
  
! 	if (itworked(SetFPos (fd, posMode, where)) && itworked(GetFPos (fd, &curPos)))
! 		return(curPos);
  	   
  	return(-1);
  }
  
  /* ---------------------------------------------------------------------- */
  
! boolean rsrc_dlb_init(void) {
  	return TRUE;
  }
  
! void rsrc_dlb_cleanup(void) {
  }
  
! boolean rsrc_dlb_fopen(dlb *dp, const char *name, const char *mode) {
! #if defined(applec) || defined(__MWERKS__)
! # pragma unused(mode)
! #endif
  	Str255 pname;
  	
  	C2P(name, pname);
